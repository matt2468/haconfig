"""
 Working on setting zwave lock codes and storing name references for entries
"""
import logging
import collections
import os.path

import homeassistant.helpers.config_validation as cv
import homeassistant.components.zwave.const as zconst
import homeassistant.config as conf_util
from homeassistant.components import persistent_notification
from homeassistant.components import logbook
from homeassistant.util.yaml  import load_yaml, dump


import voluptuous as vol
from pydispatch import dispatcher
from openzwave.network import ZWaveNetwork


_LOGGER = logging.getLogger(__name__)
DEPENDENCIES = ['zwave']
DOMAIN = 'be369group'
PERSIST_FILE = 'lockinfo.yaml'
LOCKGROUP = None

USER_CODE_ENTERED = 16
TOO_MANY_FAILED_ATTEMPTS = 96
NOT_USER_CODE_INDEXES = (0, 254, 255)  # Enrollment code, refresh and code count
USER_CODE_STATUS_BYTE = 8


def setup(hass, config):
    """ Thanks to pydispatcher being globally available in the application, we can hook into zwave here """
    global LOCKGROUP
    LOCKGROUP = BE369LockGroup(hass) 
    dispatcher.connect(LOCKGROUP.valueadded, ZWaveNetwork.SIGNAL_VALUE_ADDED)
    dispatcher.connect(LOCKGROUP.valuechanged, ZWaveNetwork.SIGNAL_VALUE_CHANGED)

    hass.services.register(DOMAIN, "setusercode", LOCKGROUP.setcode,
                { 'description': "Sets a user code on all locks",
                       'fields': { 'name': {'description': 'A name for reference'},
                                   'code': {'description': 'The number code to use as an ascii string'}}})
    hass.services.register(DOMAIN, "clearusercode", LOCKGROUP.clearcode,
                { 'description': "Clear a user code on all locks using name or index (only provide one of name/index)",
                       'fields': { 'name': {'description': 'The name for the code'},
                                  'index': {'description': 'Or the index to clear on all locks (1-19)'}}})

    return True


class BE369LockGroup:
    """
        Group all the locks info together so we can set the same code in the same slot on each lock.  The Schlage
        locks do not let you download the user codes though I really don't care to store them anyhow, I just want
        to assign a name to each entry location (a la Vera handling) so I can remember which ones to delete/reassign
        later.

        I think this BE369 use of alarms is entirely specific to this old lock, there appears to be an actual
        lock logging class for newer zwave devices.  Ah, corner cases, my old friend. The default HA ZWaveAlarmSensor
        treats zwave alarms as separate state values and therefore won't send updates if the same door code entered
        multiple times in succession, hence the zwave value change decoding below.

        We also have to resort to ugliness to get the data about UserCode availability.

        This has become pretty much all specific case work.
    """

    def __init__(self, hass):
        self.hass   = hass
        self.values = collections.defaultdict(list)  # index  -> [zwave Value obj for each lock at index]
        self.alarms = dict()                         # nodeid -> [alarmtype, alarmval]
        self.names  = dict()                         # index  -> a user defined name for this entry
        self.load_name_info()


    def load_name_info(self):
        """ Load lock code name information after restart """
        try:
            self.names = load_yaml(self.hass.config.path(PERSIST_FILE))
            _LOGGER.debug("read in state: {}".format(self.names))
        except FileNotFoundError:
            pass # we'll create a new one eventually
        except Exception as e:
            _LOGGER.warning("error loading {}: {}".format(PERSIST_FILE, e))


    def store_name_info(self):
        """ Rewrite the lock code name information """
        with open(self.hass.config.path(PERSIST_FILE), 'w') as out:
            out.write("# Autogenerated file to survive data across restarts, I wouldn't recommend editing\n")
            if len(self.names):  # barfs on empty dict
                out.write(dump(self.names))


    ###### The following are the service call methods  ########

    def setcode(self, service):
        """ Set the ascii number string code to index X on each available lock """
        name  = service.data.get('name')
        code  = service.data.get('code')

        if not all([ord(x) in range(0x30, 0x39) for x in code]):
            _LOGGER.warning("Invalid code provided to setcode ({})".format(code))
            return

        for index in range(1, 20):
            if index not in self.names:
                # Found an available spot, set it here
                for v in self.values[index]:
                    v.data = code
                self.names[index] = name
                self.store_name_info()
                return


    def clearcode(self, service):
        """ Clear a code on each lock (may be passed name or index) """
        index = -1
        if 'name' in service.data: # the one place where we have to go from value to key
            match = [k for k,v in self.names.items() if v == service.data.get('name')]
            index = len(match) and match[0] or -1
        elif 'index' in service.data:
            index = service.data.get('index')

        if index > 0 and index < 20: # BE369 specific right now
            for v in self.values[index]:
                v.data = "\0\0\0\0"  # My patch to OZW should cause a clear, wait for confirmations to update names
        else:
            _LOGGER.warning("Unable to find an index for code to clear based on arg {}".format(service.data))


    ###### The following are called based on decoding of events on the ZWave network ###########

    def lockcodestatus(self, value):
        """ We've received a new usercode status report from a lock """
        thelist = [v.available for v in self.values[value.index]]
        theset  = set(thelist)

        if None in theset: # Not all codes at this index refreshed for all locks
            pass

        elif len(theset) != 1: # some True, some False, this half-way state happens during set/clear
            _LOGGER.info("Locks disagree on availability of index {}, set = {}".format(value.index, theset))

        elif thelist[0]:  # True == Available
            if value.index in self.names: # we have a name for something that should be available, clear the name
                del self.names[value.index]
                self.store_name_info()

        else: # Occupied
            if value.index not in self.names: # we should have a name but we don't, add temp name
                self.names[value.index] = "Unnamed Entry {}".format(value.index)
                self.store_name_info()


    def lockactivity(self, nodeid, atype, aval):
        """ We have decoded a report (via alarms) from the BE369 lock """
        if atype == USER_CODE_ENTERED:
            logbook.log_entry(self.hass, "LockNameHere", 'User entered code {} at door {}'.format(self.names.get(aval, aval), nodeid))

        elif atype == TOO_MANY_FAILED_ATTEMPTS:
            msg = 'Multiple invalid door codes enetered at door {}'.format(nodeid)
            persistent_notification.create(self.hass, msg, 'Potential Prowler')
            _LOGGER.warning(msg)

        else:
            _LOGGER.warning("Unknown lock alarm type! Investigate ({}, {}, {})".format(nodeid, atype, aval))


    ###### Below is where we hook into the ZWave events and decode appropriately ##########

    def valueadded(self, node, value):
        """ New ZWave Value added (generally on network start), make note of any user code entries on generic locks """
        if (node.generic == zconst.GENERIC_TYPE_ENTRY_CONTROL and     # node is generic lock
            value.command_class == zconst.COMMAND_CLASS_USER_CODE and # command class is user code
            value.index not in NOT_USER_CODE_INDEXES):                # real user code, not other indexes

            _LOGGER.debug("registered user code location {}, {} on {}".format(value.index, value.label, value.parent_id))
            value.available = None  # unknown third state
            self.values[value.index].append(value)
            self.alarms[value.parent_id] = [None]*2


    def valuechanged(self, value):
        """ We look for usercode and alarm messages from our locks here """

        if value.command_class == zconst.COMMAND_CLASS_USER_CODE:
            # PyOZW doesn't expose command class data, we reach into the raw message data and get it ourselves
            value.available = not value.network.manager.getNodeStatistics(value.home_id, value.parent_id)['lastReceivedMessage'][USER_CODE_STATUS_BYTE]
            _LOGGER.debug("{} code {} available {}".format(value.parent_id, value.index, value.available))
            self.lockcodestatus(value)


        elif value.command_class == zconst.COMMAND_CLASS_ALARM and value.parent_id in self.alarms:
            # When we get both COMMAND_CLASS_ALARM index 0 and index 1 from a Lock, we combine, process and reset the data
            _LOGGER.debug("alarm piece {} {} on {}".format(value.index, value.data, value.parent_id))
            try:
                bits = self.alarms[value.parent_id]
                bits[value.index] = value.data
                if None not in bits:
                    self.lockactivity(value.parent_id, bits[0], bits[1])
                    bits[:] = [None]*2

            except Exception as e:
                _LOGGER.error("exception {}: got bad data? index={}, data={}".format(e, value.index, value.data))

